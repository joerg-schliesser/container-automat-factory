/*
 * Copyright 2024 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package de.containerautomat.factory.builders;

import de.containerautomat.factory.ContainerAutomatFactoryApp;
import de.containerautomat.factory.api.DfaApplicationParameters;
import de.containerautomat.factory.outlets.AppGenerationOutlet;
import lombok.Getter;
import lombok.SneakyThrows;
import org.springframework.core.io.ClassPathResource;
import org.springframework.util.FileCopyUtils;

import java.io.IOException;
import java.io.InputStream;
import java.nio.charset.StandardCharsets;
import java.time.Instant;

import static de.containerautomat.factory.builders.ApplicationTemplatesConstants.*;

/**
 * A class that provides basic, general methods for generating
 * a Container-Automat application based on the description of a
 * Deterministic Finite Automaton (DFA).
 * <p/>
 * For the generation of some sub-areas of the application, the classes
 * {@link JavaAppBuilder}, {@link DockerAppBuilder} and {@link TargetFileCommentBuilder}
 * are delegated to during the generation process.
 */
public class DfaApplicationBuilder {

    public enum TargetFileType {
        CMD, CONF, DOCKERFILE, DOCKERIGNORE, ENV, JAVA, JSON, MD, PROPERTIES, SH, YML, XML
    }


    @Getter
    private final DfaApplicationParameters dfaApplicationParameters;

    @Getter
    private final ApplicationMetaData applicationMetaData;

    private final AppGenerationOutlet appGenerationOutlet;


    public DfaApplicationBuilder(DfaApplicationParameters dfaApplicationParameters, AppGenerationOutlet appGenerationOutlet) {

        this.dfaApplicationParameters = dfaApplicationParameters;
        this.applicationMetaData = dfaApplicationParameters.getApplicationMetaData();
        this.appGenerationOutlet = appGenerationOutlet;
    }

    public void createApplicationFiles() {

        var javaAppBuilder = createJavaAppBuilder();
        javaAppBuilder.createPomFiles();
        javaAppBuilder.createJavaFiles();
        javaAppBuilder.createResourceFiles();
        javaAppBuilder.createLocalRunFiles();

        var dockerAppBuilder = createDockerAppBuilder();
        dockerAppBuilder.createDockerBuildFiles();
        dockerAppBuilder.createDockerComposeFiles();

        createReadmeFile();
    }

    @SneakyThrows
    void createReadmeFile() {

        var readmeHeader = """
                # %1$s (a generated application)

                Generated by Container-Automat Factory

                    %2$s
                    Time of generation: %3$s

                ## Preliminary notes

                - Container-Automat is a generator of service-oriented applications for
                  demonstration purposes that are based on Deterministic Finite Automata
                  (abbreviated DFA).
                - Further information is available on the project website at:
                  [www.container-automat.de](https://www.container-automat.de).
                - The Container-Automat Factory as such is open source software licensed
                  under the Apache License, Version 2.0. You may obtain a copy of the license at:
                  https://www.apache.org/licenses/LICENSE-2.0
                - Please note that generated applications use external services like a
                  message broker, a database, and optional possibly others. Depending on the
                  environment in which the application is running and the organization using
                  it, different licensing requirements may apply to these services.
                """.formatted(applicationMetaData.getAppName(), ContainerAutomatFactoryApp.class.getCanonicalName(), Instant.now());

        var sourceText = readTemplateResource("resources/README.md.txt");
        var targetText = resolveApplicationAndServicePlaceholders(sourceText);
        targetText = readmeHeader + targetText;
        writeTargetFile(targetText, "README.md");
    }

    void createTargetFiles(String[] fileTemplates, String[] fileTargets) throws IOException {

        for (int templateIndex = 0; templateIndex < fileTemplates.length; templateIndex++) {
            var sourceText = readTemplateResource(fileTemplates[templateIndex]);
            var targetText = resolveApplicationAndServicePlaceholders(sourceText);
            targetText = applicationMetaData.resolveOptionalServicePlaceholders(targetText);
            writeTargetFile(targetText, fileTargets[templateIndex]);
        }
    }

    String resolveApplicationAndServicePlaceholders(String sourceText) {

        var result = applicationMetaData.removeUnneededMessagingTypeSections(sourceText);
        result = applicationMetaData.removeUnneededStorageTypeSections(result);
        result = result.replace(CONTAINER_REGISTRY_PLACEHOLDER, applicationMetaData.getContainerRegistry());
        result = result.replace(CONTAINER_AUTOMAT, applicationMetaData.getAppName());
        result = result.replace(CONTAINER_AUTOMAT_LOWERCASE, applicationMetaData.getAppName().toLowerCase());
        result = result.replace(CONTAINER_AUTOMAT_CAMELCASE, applicationMetaData.getAppName().toLowerCase());
        result = result.replace(CONTAINER_AUTOMAT_KEBABCASE, applicationMetaData.getAppName().toLowerCase());
        result = result.replace(CONTAINER_AUTOMAT_UPPERCASE, applicationMetaData.getAppName().toUpperCase());
        return result;
    }

    String resolveStateSpecificPlaceholders(String sourceText, String stateName, int stateNumber, int managementPort) {

        var result = sourceText.replace(STATE_NUMBER_PLACEHOLDER, Integer.toString(stateNumber));
        result = result.replace(STATE_NAME_PLACEHOLDER, stateName);
        result = result.replace(STATE_MANAGEMENT_PORT_PLACEHOLDER, Integer.toString(managementPort));
        return result;
    }

    String readTemplateResource(String templatePath) throws IOException {

        var classPathResource = new ClassPathResource(TEMPLATES_PARENT_FOLDER + templatePath);
        try (InputStream inputStream = classPathResource.getInputStream()) {
            byte[] bytes = FileCopyUtils.copyToByteArray(inputStream);
            return new String(bytes, StandardCharsets.UTF_8);
        }
    }

    void writeTargetFile(String data, String targetFilePathTemplate) throws IOException {

        if (targetFilePathTemplate.endsWith(".sh")) {
            data = data.replace("\r\n", "\n");
        }

        var targetFilePath = targetFilePathTemplate.replace(CONTAINER_AUTOMAT_KEBABCASE, applicationMetaData.getAppName().toLowerCase());
        var fileExtension = targetFilePath.substring(targetFilePath.lastIndexOf('.') + 1).toUpperCase();
        var targetFileType = TargetFileType.valueOf(fileExtension);

        if (targetFileType == TargetFileType.JAVA) {
            var targetStart = data.indexOf(JAVA_PACKAGE_LINE_PREFIX);
            data = data.substring(targetStart);
        }

        if (TargetFileCommentBuilder.isCommentedTargetFileType(targetFileType)) {
            data = TargetFileCommentBuilder.insertGeneratorComment(data, targetFileType);
        }

        appGenerationOutlet.writeTargetFile(data, targetFilePath);
    }

    JavaAppBuilder createJavaAppBuilder() {
        return new JavaAppBuilder(this);
    }

    DockerAppBuilder createDockerAppBuilder() {
        return new DockerAppBuilder(this);
    }

}
